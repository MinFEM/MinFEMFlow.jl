"""
$(TYPEDEF)

Stores all data that is static throughout iteration of the interior-point method.
Is supposed to be generated by corresponding constructor.

# Fields
$(TYPEDFIELDS)
"""
mutable struct FlowSolver
    "Meshed computational domain"
    mesh::Mesh

    "Inflow boundary with prescribed Dirichlet velocity"
    inflow_boundary::Set{Int64}

    "No-slip boundary with prescribed Dirichlet values"
    noslip_boundary::Set{Int64}

    "Inflow velocity function"
    inflow::Vector{Float64}

    "Switch for writing output during solve"
    verbose::Bool

    "Flow solution routine inherently determining the flow type"
    solve::Function

    "Resulting velocity field"
    v::Union{Missing, Vector{Float64}}

    "Resulting pressure"
    p::Union{Missing, Vector{Float64}}

    "Required solution time also validating if a result is present"
    time::Union{Missing, Float64}
end

"""
$(TYPEDSIGNATURES)

Removes result, i.e. velocity, pressure and time, from given FlowSolver.
"""
function invalidate!(fs::FlowSolver)
    fs.v = missing
    fs.p = missing
    fs.time = missing
end

"""
$(TYPEDSIGNATURES)

Updates mesh and then invalidates the solution.
"""
function set_mesh!(fs::FlowSolver, mesh::Mesh)
    fs.mesh = mesh
    invalidate!(fs)
end

"""
$(TYPEDSIGNATURES)

Updates inflow boundary and then invalidates the solution.
"""
function set_boundary_inflow!(fs::FlowSolver, boundary::Union{Set{Boundary}, Set{Int64}})
    _boundary = boundary isa Set{Boundary} ? extract_nodes(boundary) : boundary
    fs.inflow_boundary = _boundary
    invalidate!(fs)
end

"""
$(TYPEDSIGNATURES)

Updates no slip boundary and then invalidates the solution.
"""
function set_boundary_noslip!(fs::FlowSolver, boundary::Union{Set{Boundary}, Set{Int64}})
    _boundary = boundary isa Set{Boundary} ? extract_nodes(boundary) : boundary
    fs.noslip_boundary = _boundary
    invalidate!(fs)
end

"""
$(TYPEDSIGNATURES)

Updates inflow function and then invalidates the solution.
"""
function set_inflow!(fs::FlowSolver, inflow::Union{Vector{Float64}, Function})
    _inflow = inflow isa Function ?
        evaluate_mesh_function(mesh, inflow, fs.inflow_boundary, qdim=mesh.d) : inflow

    fs.inflow = _inflow
    invalidate!(fs)
end

"""
$(TYPEDSIGNATURES)

Updates wether output shall be written to console.
"""
function set_verbose!(fs::FlowSolver, verbose::Bool)
    fs.verbose = verbose
end

"""
$(TYPEDSIGNATURES)

Set results for a FlowSolver.
Does not check if solution matches the problem.
"""
function set_result!(
    fs::FlowSolver,
    v::Vector{Float64},
    p::Vector{Float64},
    t::Float64
)
    fs.v = v
    fs.p = p
    fs.time = t
end

"""
$(TYPEDSIGNATURES)

Copies result from one flow solver to another.
Does not check if problems in the solvers match.
"""
function copy_result!(
    target::FlowSolver,
    origin::FlowSolver
)
    set_result!(
        target,
        copy(origin.v),
        copy(origin.p),
        copy(origin.time)
    )
end

"""
$(TYPEDSIGNATURES)

Solves flow by calling the internal routine.
"""
function solve!(fs::FlowSolver)
    if !ismissing(fs.time)
        return
    end

    fs.solve(fs)
end

"""
$(TYPEDSIGNATURES)

Writes velocity and pressure of the solved flow to a .vtu-file under the given file_name.
"""
function write_to_vtk(fs::FlowSolver, file_name::String)
    if !ismissing(fs.time)
        write_to_vtk([fs.v, fs.p], fs.mesh, ["v","p"], file_name, [fs.mesh.d,1])
    else
        throw(MissingException("No flow solution available to write."))
    end
end
